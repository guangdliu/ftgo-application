package net.chrisrichardson.ftgo.orderservice.contract;

import io.eventuate.common.json.mapper.JSonMapper;
import io.restassured.module.mockmvc.RestAssuredMockMvc;
import net.chrisrichardson.ftgo.common.CommonJsonMapperInitializer;
import net.chrisrichardson.ftgo.orderservice.OrderDetailsMother;
import net.chrisrichardson.ftgo.orderservice.domain.OrderRepository;
import net.chrisrichardson.ftgo.orderservice.domain.OrderService;
import net.chrisrichardson.ftgo.orderservice.web.OrderController;
import org.junit.Before;
import org.springframework.http.converter.json.MappingJackson2HttpMessageConverter;
import org.springframework.test.web.servlet.setup.MockMvcBuilders;
import org.springframework.test.web.servlet.setup.StandaloneMockMvcBuilder;

import java.util.Optional;

import static java.util.Optional.empty;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.when;

/***
Spring Cloud Contract generate a test class called HttPBase, which uses Rest Assured Mock
MVC to test OrderService's controller. 

This is the integration testing for provider (OrderService). HttpBase is a consumer client. 
It uses RestAssuredMockMvc to send a request defined in the contract, and expects the provider
(OrderController) sends back a response which should be the same as the one defined
in the contract. 

https://www.baeldung.com/spring-cloud-contract
Note that we write this HttpBase class by ourselves. 
It loads our Spring context.

This is one way mentioned in balelung
we'll need to configure spring-cloud-contract-maven-plugin with the name of our base test class 
e.g. HttpBase

<plugin>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-contract-maven-plugin</artifactId>
    <version>2.1.1.RELEASE</version>
    <extensions>true</extensions>
    <configuration>
        <baseClassForTests>
            net.chrisrichardson.ftgo.orderservice.contract.HttpBase
        </baseClassForTests>
    </configuration>
</plugin>

This is the way used in the book from ftgo-order-service build.gradle

contracts {
    contractsDslDir = new File("../ftgo-order-service-contracts/src/main/resources/contracts")
    packageWithBaseClasses = 'net.chrisrichardson.ftgo.orderservice.contract'
    generatedTestSourcesDir = project.file("${project.buildDir}/generated-integration-test-sources/contracts")
}

I guess all classes in net.chrisrichardson.ftgo.orderservice.contract are treated as base class.
If you check 
../ftgo-order-service-contracts/src/main/resources/contracts

 it has two types of contracts:
 contracts.http
 contracts.messaging
 
 I guess the name above help find the right base for a contract. This is confirmed from here:
 
 http://antkorwin.com/cloud/spring_cloud_contract_junit5.html#_different_base_classes_for_different_test_cases
 
3.5. Different base classes for different test cases
 
Often we have test cases with a different initialization logic. For example, when you test a creating of something, you don¡¯t need to prepare in the database the already created records. But if you test a reading of something from a database, then you need to be sure that read data sets exist in the database.

You can set a package with the base classes for tests generate, instead of setting a one base class for all tests.

<plugin>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-contract-maven-plugin</artifactId>
    <version>2.1.0.BUILD-SNAPSHOT</version>
    <extensions>true</extensions>
    <configuration>
        <packageWithBaseClasses>com.antkorwin.taskservice.api.contract</packageWithBaseClasses> 
        <testFramework>JUNIT5</testFramework>
    </configuration>
</plugin> 

And now, you need to keep your contracts directory in the next kind:


The names of your base classes depend on the structure of the contracts package, you need to reflect the names of directories in the name of the base class.
e.g. contracts.http needs HttpBase, contracts.messaging needs MessagingBase


When we run the build (e.g. ./gradlew buildContracts),
the  spring-cloud-contract-maven-plugin automatically generates a test class which
extends HttpBase





CONSUMER-DRIVEN CONTRACT INTEGRATION TESTS FOR ORDER SERVICE
The consumer-driven contract integration tests for Order Service verify that its API
meets its clients¡¯ expectations. Listing 10.3 shows HttpBase, which is the base class
for the test class code-generated by Spring Cloud Contract. It¡¯s responsible for the
setup phase of the test. It creates the controllers injected with mock dependencies
and configures those mocks to return values that cause the controller to generate the
expected response.

***/
public abstract class AnnotatedHttpBase {

  private StandaloneMockMvcBuilder controllers(Object... controllers) {
    CommonJsonMapperInitializer.registerMoneyModule();
    MappingJackson2HttpMessageConverter converter = new MappingJackson2HttpMessageConverter(JSonMapper.objectMapper);
    return MockMvcBuilders.standaloneSetup(controllers).setMessageConverters(converter);
  }

  @Before
  public void setup() {
    OrderService orderService = mock(OrderService.class);
    ///1 Create OrderRepository injected with mocks.
    OrderRepository orderRepository = mock(OrderRepository.class);
    OrderController orderController = new OrderController(orderService, orderRepository);

    ///2 Configure OrderResponse to return an Order when findById is invoked with the OrderId specified in the contract
    when(orderRepository.findById(OrderDetailsMother.ORDER_ID)).thenReturn(Optional.of(OrderDetailsMother.CHICKEN_VINDALOO_ORDER));
    when(orderRepository.findById(555L)).thenReturn(empty());
    /// 3 Configure Spring MVC with OrderController
    RestAssuredMockMvc.standaloneSetup(controllers(orderController));

    /***
    When a request comes (e.g. the one defined in the contract),
    OrderController will use orderRepository to find an order. 
    orderRepository is configured to return predefined order.
    orderController returns these predefined order. 
    As long as it can return these predefined order, 
    it means it's  
    
    ***/
  }
}