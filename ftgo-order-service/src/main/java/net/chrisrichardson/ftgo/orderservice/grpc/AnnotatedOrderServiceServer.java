package net.chrisrichardson.ftgo.orderservice.grpc;

import io.grpc.Server;
import io.grpc.ServerBuilder;
import io.grpc.stub.StreamObserver;
import net.chrisrichardson.ftgo.orderservice.domain.Order;
import net.chrisrichardson.ftgo.orderservice.domain.OrderService;
import net.chrisrichardson.ftgo.orderservice.web.MenuItemIdAndQuantity;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.annotation.PostConstruct;
import javax.annotation.PreDestroy;
import java.io.IOException;

import static java.util.stream.Collectors.toList;

/***
gRPC uses Protocol Buffers as the message format. 
You define gRPC APIs using a Protocal Buffere based IDL. 
You use the Protocol Buffer compiler to generate code for 
a variety of languages, including Java, C# ...
Clients and servers exchange binary messages in the Protocol Buffers
format using HTTP/2.
Check OrderService.proto for the message related to OrderService
.
OrderServiceGrpc is the code generated by protocol buffer compiler.

A message recipient (client) can extract the fields that it needs,
and SKIP over the field that it doesn't recognize. As a result, 
gRPC enables APIs to evolve while remaining backward-compatible.


***/
public class AnnotatedOrderServiceServer {
  private static final Logger logger = LoggerFactory.getLogger(AnnotatedOrderServiceServer.class);

  private int port = 50051;
  ///io.gprc.Server
  private Server server;
  private OrderService orderService;

  /***
  This constructor is called in GrpcConfiguration.java
  After that, @PostConstruct is going to start the server.
  
  GrpcConfiguration is called in OrderServiceGrpIntegrationTestConfiguration
  and OrderServiceMain. OrderServiceMain is a SpringBootApplication which itself is a server.
  
  Basically, OrderService's server OrderServiceMain starts a grpc server which listens to 50051
  port. 
  
  ***/
  public AnnotatedOrderServiceServer(OrderService orderService) {
    this.orderService = orderService;
  }

  @PostConstruct
  public void start() throws IOException {
    server = ServerBuilder.forPort(port)
            .addService(new OrderServiceImpl())
            .build()
            .start();
    logger.info("Server started, listening on " + port);
  }

  @PreDestroy
  public void stop() {
    if (server != null) {
      logger.info("*** shutting down gRPC server since JVM is shutting down");
      server.shutdown();
      logger.info("*** server shut down");
    }
  }


  ///OrderServiceImpl is a grp service implementation
  ///Note that OrderServiceGrpc is generated by grpc by reading the IDL OrderService.proto
  private class OrderServiceImpl extends OrderServiceGrpc.OrderServiceImplBase {

    @Override
    public void createOrder(CreateOrderRequest req, StreamObserver<CreateOrderReply> responseObserver) {
      Order order = orderService.createOrder(req.getConsumerId(),
              req.getRestaurantId(),
              req.getLineItemsList().stream().map(x -> new MenuItemIdAndQuantity(x.getMenuItemId(), x.getQuantity())).collect(toList())
      );
      CreateOrderReply reply = CreateOrderReply.newBuilder().setOrderId(order.getId()).build();
      responseObserver.onNext(reply);
      responseObserver.onCompleted();
    }

    @Override
    public void cancelOrder(CancelOrderRequest req, StreamObserver<CancelOrderReply> responseObserver) {
      CancelOrderReply reply = CancelOrderReply.newBuilder().setMessage("Hello " + req.getName()).build();
      responseObserver.onNext(reply);
      responseObserver.onCompleted();
    }

    @Override
    public void reviseOrder(ReviseOrderRequest req, StreamObserver<ReviseOrderReply> responseObserver) {
      ReviseOrderReply reply = ReviseOrderReply.newBuilder().setMessage("Hello " + req.getName()).build();
      responseObserver.onNext(reply);
      responseObserver.onCompleted();
    }
  }
}
