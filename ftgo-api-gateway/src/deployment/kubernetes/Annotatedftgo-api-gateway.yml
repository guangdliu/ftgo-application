/***
Kitchen service should only be accessible only from within the cluster. (Cluster IP by default)
API gateway should be also accessible to outside (NodePort type). 

API Gateway is within the clustering using the URL http://ftgo-api-gateway and outside the URL
http://<node-ip-address>:3000
AWS Elastic Load Balance (ELB) routes the requests from internet to the nodes. 

https://stackoverflow.com/questions/49981601/difference-between-targetport-and-port-in-kubernetes-service-definition

71

Service: This directs the traffic to a pod.

TargetPort: This is the actual port on which your application is running inside the container.

Port: This is the port exposed to other services in the same cluster. They hit port and kubernets forward the 
traffic of port within the cluster to targetPort. 


kind: Service
apiVersion: v1
metadata:
  name: my-service
spec:
  selector:
    app: MyApp
  ports:
    - name: http
      nodePort: 30475
      port: 8089
      protocol: TCP
      targetPort: 8080 /// container port
    - name: metrics
      nodePort: 31261
      port: 5555
      protocol: TCP
      targetPort: 5555
    - name: health
      nodePort: 30013
      port: 8443
      protocol: TCP
      targetPort: 8085 
if you hit the my-service:8089 the traffic is routed to 8080 of the container(targetPort). 
Similarly, if you hit my-service:8443 then it is redirected to 8085 of the container(targetPort). 
But this myservice:8089 is internal to the kubernetes cluster 
and can be used when one application wants to communicate with another application. 

So to hit the service from outside the cluster someone needs to expose the port on the host machine 
on which kubernetes is running so that the traffic is redirected to a port of the container.
This is node port(port exposed on the host machine). 
From the above example, 
you can hit the service from outside the cluster(Postman or any rest-client) by host_ip:nodePort

Say your host machine ip is 10.10.20.20 you can hit the http, metrics, health services by 10.10.20.20:30475, 10.10.20.20:31261, 10.10.20.20:30013
***/
---
apiVersion: v1
kind: Service
metadata:
  name: ftgo-api-gateway
  labels:
    name: ftgo-api-gateway
    application: ftgo
spec:
  ports:
  - port: 80
    targetPort: 8080
  selector:
    svc: ftgo-api-gateway
#  type: LoadBalancer
#  loadBalancerSourceRanges:
#    - 88.128.82.195/32
---
apiVersion: extensions/v1beta1
kind: Deployment
metadata:
/*** In order to run multiple versions of a service simultaneously, the name of a Kubernetes
deployment must include the version, such as ftgo-api-gateway-v2. A deployment's pods should have
a version label, such as version: v1, which sepcifies the version, so that Istio can route to a 
specific version.

These version info is processed by istio. istio is a service mesh. A service mesh is a networking
infrastructure that mediates all communication between a service and other services and external
applications. A service mesh can also provide rule-based load balancing and traffic routing that 
lets you safely run multiple versions of your services simutaneously. 

Istio is configured using Kubernetes-style YAML configuration files. 
Actually, they can use the same configuration file.
It has a command-line called
istioctl. You use istioctl for creating, updating and deleting rules and policies. 

istioctl kube-inject -f ftgo-consumer-service/src/deployment/kubernetes/ftgo-consumer-service.yml 
| kubectl apply -f -

This command reads a Kubernetes YAML file and outputs the modified configuration containing the Envoy
proxy. The modified configuration is then piped into kubectl apply. 

***/
  name: ftgo-api-gateway///-v2 versioned deployment
  labels:
    application: ftgo
spec:
  replicas: 1
  strategy:
    rollingUpdate:
      maxUnavailable: 0
  template:
    metadata:
      labels:
        svc: ftgo-api-gateway
        application: ftgo
        /// version: v2 /// Recommended labels
    spec:
      containers:
      - name: ftgo-api-gateway
        image: msapatterns/ftgo-api-gateway:latest /// image: ftgo-consumer-service:v2
        imagePullPolicy: Always
        ports:
        - containerPort: 8080
          name: httpport
        env:
          - name: JAVA_OPTS
            value: "-Dsun.net.inetaddr.ttl=30"
          - name: ORDER_DESTINATIONS_ORDERSERVICEURL /// api gateway talks to order service through this config
            value: http://ftgo-order-service:8080
          - name: ORDER_DESTINATIONS_ORDERHISTORYSERVICEURL /// api gateway talks to order history through this config 
            value: http://ftgo-order-history-service:8080
          - name: CONSUMER_DESTINATIONS_CONSUMERSERVICEURL /// api gateway talks to consumer through this config
            value: http://ftgo-consumer-service:8080
        livenessProbe:
          httpGet:
            path: /actuator/health
            port: 8080
          initialDelaySeconds: 30
          periodSeconds: 20
        readinessProbe:
          httpGet:
            path: /actuator/health /// Spring Boot Actuator implements this. I thin you only needs to include 
            					   /// the jar file in maven or grade, then this endpoint can be hit.
            port: 8080
          initialDelaySeconds: 30
          periodSeconds: 20

---
